//
//  CloudyRecFstore.m
//  Generated by CloudyRec - mobile backend platform.
//  Copyright (c) 2012 Rival Edge Pte Ltd. All rights reserved.
//

#import "CloudyRecFstore.h"
#import "CloudyRecConnector.h"
#import "JSONKit.h"

@implementation CloudyRecFstore
-(void)uploadWithData:(NSData*)data FileName:(NSString*)filename ContentType:(NSString*)contentType ID:(NSString*)__id onCompletion:(httpResponseBlock)completion OnFailer:(httpErrorBlock)fail {
  
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  
  if(contentType==nil) {
    contentType=@"application/octet-stream";
  }

  NSString* url;
  if(__id==nil)
  {
    //url ="/" + version + "/" + appKey + "/fstore"
    url =[NSString stringWithFormat:@"/%@/%@/fstore",self.version,self.appKey];
  }
  else {
    url =[NSString stringWithFormat:@"/%@/%@/fstore/%@",self.version,self.appKey,__id];
  }
  
  
  [conx httpPostMultipartWithURL:url Data:data ContentType:contentType FileName:filename onCompletion:^(SimpleHttpResponse* respond){
    NSError* error;
    [self checkAndRaiseError:respond Error:&error];
    
    if(error!=nil) {
        fail(error);
    }
    else {
      completion(respond);
    }
    [conx release];
  }OnFailer:^(NSError* error){
    fail(error);
    [conx release];
  }];
}

-(void)listWithCompletion:(cloudyRecRespondBlock)completion OnFailer:(httpErrorBlock)fail {
  [self listWithQuery:nil Limit:10 Page:1 onCompletion:completion OnFailer:fail];
}
-(void)listWithQuery:(NSString*)query Limit:(int)limit Page:(int)page onCompletion:(cloudyRecRespondBlock)completion OnFailer:(httpErrorBlock)fail {
  
  if (limit < 0) {
    limit = 10;
  }
  if (page < 0) {
    page = 1;
  }
  
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  NSDictionary* dictionary;
  if(query!=nil) {
          dictionary = [[NSDictionary alloc] initWithObjectsAndKeys:[NSString stringWithFormat:@"%d",limit],@"limit",
                        [NSString stringWithFormat:@"%d",page],@"page",query,@"query",nil];
  }
  else {
    dictionary = [[NSDictionary alloc] initWithObjectsAndKeys:[NSString stringWithFormat:@"%d",limit],@"limit",
                  [NSString stringWithFormat:@"%d",page],@"page",nil];
  }

  NSString* url =[NSString stringWithFormat:@"/%@/%@/fstore/list",self.version,self.appKey];
  
  [conx httpGet:url Data:dictionary onCompletion:^(SimpleHttpResponse* respond){
    
    NSError* error;
    [self checkAndRaiseError:respond Error:&error];
    
    if(error!=nil) {
      fail(error);
    }
    else {
       NSArray* arr = [respond.body objectFromJSONString];
      completion(arr);
    }
    
    [conx release];
    
  }OnFailer:^(NSError* err){
    fail(err);
    [conx release];
  }];
}

-(void)setTagWithID:(NSString*)tagID Tags:(NSArray*)tagsList onCompletion:(cloudyRecRespondStirngBlock)completion OnFailer:(httpErrorBlock)fail {
  
  NSString* tags = [tagsList componentsJoinedByString:@","];
  
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  NSDictionary* data =[[NSDictionary alloc] initWithObjectsAndKeys:tags,@"tags", nil];
  //"/" + self.version + "/" + self.appKey + "/fstore/" + self._id + "/tags";
  NSString* url = [NSString stringWithFormat:@"/%@/%@/fstore/%@/tags",self.version,self.appKey,tagID];
  
  [conx httpPut:url Data:data onCompletion:^(SimpleHttpResponse* respond){
    
    NSError* error;
    [self checkAndRaiseError:respond Error:&error];
    
    if(error!=nil) {
      fail(error);
    }
    else {
      completion(respond.body); 
    }
    [data release];
    [conx release];
    
  }OnFailer:^(NSError* error){
    fail(error);
    [data release];
    [conx release];
  }];
  
}
-(void)getTagWithID:(NSString*)tagID onCompletion:(cloudyRecRespondBlock)completion onFailer:(httpErrorBlock)fail {
  //"/" + version + "/" + appKey + "/"+ "fstore/" + id + "/tags"
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  
  NSString* url =[NSString stringWithFormat:@"/%@/%@/fstore/%@/tags",self.version,self.appKey,tagID];
  [conx httpGet:url Data:nil onCompletion:^(SimpleHttpResponse* respond){
    
    
    NSError* error;
    [self checkAndRaiseError:respond Error:&error];
    
    if(error!=nil) {
      fail(error);
    }
    else {
      NSDictionary* dict = [respond.body objectFromJSONString];
      completion([dict objectForKey:@"tags"]);
    }
  }OnFailer:^(NSError* error){
    fail(error);
    [conx release];
  }];
}

-(void)deleteTagWithID:(NSString*)tagID onCompletion:(cloudyRecRespondBoolBlock)completion onFailer:(httpErrorBlock)fail {
  
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  
  NSString* url =[NSString stringWithFormat:@"/%@/%@/fstore/%@",self.version,self.appKey,tagID];

  [conx httpDelete:url Data:nil onCompletion:^(SimpleHttpResponse* respond){
    if(respond.status == 204) {
      
      NSError* error;
      [self checkAndRaiseError:respond Error:&error];
      
      if(error!=nil) {
        fail(error);
      }
      else {
        completion(YES);
      }
    }
    else {
      completion(NO);
    }
    [conx release];
    
  }OnFailer:^(NSError* error){
    fail(error);
    [conx release];
  }];
 
}

-(void)downloadWithID:(NSString*)tagID onCompletion:(cloudyRecRespondDataBlock)completion onFailer:(httpErrorBlock)fail {
  
  CloudyRecConnector* conx = [[CloudyRecConnector alloc] init];
  
  NSString* url =[NSString stringWithFormat:@"/%@/%@/fstore/%@",self.version,self.appKey,tagID];
  
  [conx httpDownload:url Data:nil onCompletion:^(SimpleHttpResponse* respond){
    
    NSError* error;
    [self checkAndRaiseError:respond Error:&error];
    
    if(error!=nil) {
      fail(error);
    }
    else {
      completion(respond.rawData);
    }
    
  }OnFailer:^(NSError* error){
    fail(error);
  }];
}
@end
