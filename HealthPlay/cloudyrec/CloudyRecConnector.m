//
//  CloudyRecConnector.m
//  Generated by CloudyRec - mobile backend platform.
//  Copyright (c) 2012 Rival Edge Pte Ltd. All rights reserved.
//

#import "CloudyRecConnector.h"
#import "OAuthConsumer.h"
#import "OADataFetcher.h"

# define CONSUMER_KEY @"vcMzplp55xJMI54m2ImAQ"
# define CONSUMER_SECRET @"GnZnAbDc5ezhW7OK4ulhaw"

typedef enum{
  GET=0,
  POST,
  PUT,
  DELETE
}HttpMethod;

static httpResponseBlock _httpResponseBlock;
static httpErrorBlock _httpErrorBlock;

@interface CloudyRecConnector(Private)

-(void)Request:(NSString*)requesturl Method:(HttpMethod)method Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail;
-(void)downloadRequest:(NSString*)requesturl Method:(HttpMethod)method Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail;
-(NSString*)buildQuery:(NSDictionary*)data;
-(void)startConnection;
-(void)nextConnection;
@end

@implementation CloudyRecConnector
@synthesize scheme;
@synthesize host;
@synthesize port;
@synthesize respond;
@synthesize queue;
@synthesize downloading;
-(void)dealloc {

  [respond release];
  [scheme release];
  [host release];
  [super dealloc];
}

-(id)init {
  if(self=[super init])
  {
    [self setScheme:@"http"];
    [self setHost:@"sandbox.cloudyrec.com"];
    [self setPort:80];
    
    if(!respond)
    {
      respond = [[SimpleHttpResponse alloc] init];
    }
    
    if(!queue)
    {
            queue = [[NSMutableArray alloc] init];
    }

    [self setDownloading:NO];
    
  }
  return self;
}

-(void)httpGet:(NSString*)url Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  [self Request:url Method:GET Data:data onCompletion:completion onFailure:fail];
  
}

-(void)httpDownload:(NSString*)url Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  [self downloadRequest:url Method:GET Data:data onCompletion:completion onFailure:fail];
  
}
-(void)httpPost:(NSString*)url Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  [self Request:url Method:POST Data:data onCompletion:completion onFailure:fail];
  
}

-(void)httpPut:(NSString*)url Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  [self Request:url Method:PUT Data:data onCompletion:completion onFailure:fail];
  
}

-(void)httpDelete:(NSString*)url Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  [self Request:url Method:DELETE Data:data onCompletion:completion onFailure:fail];

}

-(void)httpPostMultipartWithURL:(NSString*)url Data:(NSData*)data ContentType:(NSString*)fcontentType FileName:(NSString*)fileName onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  
  NSString *requestedURL;
  if([[url substringToIndex:1] isEqualToString:@"/"]){ 
    requestedURL=[NSString stringWithFormat:@"%@://%@:%d%@",self.scheme,self.host,self.port,url];
  }
  else {
    requestedURL=[NSString stringWithFormat:@"%@://%@:%d/%@",self.scheme,self.host,self.port,url];
  }
  
  OAConsumer *consumer = [[OAConsumer alloc] initWithKey:CONSUMER_KEY
                                                  secret:CONSUMER_SECRET];
  
  OAMutableURLRequest *request =[[OAMutableURLRequest alloc] initWithURL:[NSURL URLWithString:requestedURL] consumer:consumer token:nil realm:nil signatureProvider:nil];
  
  [request setURL:[NSURL URLWithString:requestedURL]];
  [request setHTTPMethod:@"POST"];
  
  /*
   Set Header and content type of your request.
   */
  NSString *boundary = [NSString stringWithString:@"---------------------------12345678912345"];
  NSString *contentType = [NSString stringWithFormat:@"multipart/form-data; boundary=%@",boundary];
  [request addValue:contentType forHTTPHeaderField: @"Content-Type"];
  
  NSMutableData* body =[[NSMutableData alloc] init];
  
  NSString* file = [NSString stringWithFormat:@"Content-Disposition: form-data; name=\"file\"; filename=\"%@\"\r\n",fileName];
  [body appendData:[[NSString stringWithFormat:@"--%@\r\n", boundary] dataUsingEncoding:NSUTF8StringEncoding]];
  [body appendData:[[NSString stringWithString:file] dataUsingEncoding:NSUTF8StringEncoding]];
  [body appendData:[[NSString stringWithFormat:@"Content-Type: %@\r\n\r\n",fcontentType] dataUsingEncoding:NSUTF8StringEncoding]];
  [body appendData:[NSData dataWithData:data]];
  [body appendData:[[NSString stringWithString:@"\r\n"] dataUsingEncoding:NSUTF8StringEncoding]];
  [body appendData:[[NSString stringWithFormat:@"--%@--",boundary] dataUsingEncoding:NSUTF8StringEncoding]];
  
  // set body with request.
  [request setHTTPBody:body];
  [request addValue:[NSString stringWithFormat:@"%d", [body length]] forHTTPHeaderField:@"Content-Length"];

 NSDictionary* dictObject =[[NSDictionary alloc] initWithObjectsAndKeys:request,@"request",[[completion copy] autorelease],@"completion",[[fail copy] autorelease],@"fail",nil]; 
  
  [self.queue addObject:dictObject];
  [dictObject release];
  [body release];

  [request release];
  [consumer release];
  
  if([self.queue count]==1) {
    [UIApplication sharedApplication].networkActivityIndicatorVisible=YES;
      [self startConnection];
  }
//  
//  self.connection = [[NSURLConnection alloc] initWithRequest:request delegate:self]; // release later
//  self.receivedData = [NSMutableData data];

}
#pragma mark - Private

-(void)downloadRequest:(NSString*)requesturl Method:(HttpMethod)method Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  NSDictionary* dictObject =[[NSDictionary alloc] initWithObjectsAndKeys:requesturl,@"url",
                             [NSNumber numberWithInt:method],@"method",
                             @"download",@"type",                             
			     [[completion copy] autorelease],@"completion",
                             [[fail copy] autorelease],@"fail",
                             data,@"data",nil];
  
  [self.queue addObject:dictObject];
  [dictObject release];
  
  if([self.queue count]==1) {
    [UIApplication sharedApplication].networkActivityIndicatorVisible=YES;
    [self startConnection];
  }
}

-(void)Request:(NSString*)requesturl Method:(HttpMethod)method Data:(NSDictionary*)data onCompletion:(httpResponseBlock)completion onFailure:(httpErrorBlock)fail {
  
  NSDictionary* dictObject =[[NSDictionary alloc] initWithObjectsAndKeys:requesturl,@"url",
			    [NSNumber numberWithInt:method],@"method",
			    [[completion copy] autorelease],
                            @"completion",[[fail copy] autorelease],
                            @"fail",data,@"data",nil];
  
  
  [self.queue addObject:dictObject];
  [dictObject release];
  
  if([self.queue count]==1) {
    [UIApplication sharedApplication].networkActivityIndicatorVisible=YES;
    [self startConnection];
  }
  
  
}

-(void)startConnection {
  
  NSDictionary* dictObject =[self.queue objectAtIndex:0];
  
  NSString* requesturl =[dictObject objectForKey:@"url"];
  HttpMethod method =[[dictObject objectForKey:@"method"] intValue];
  NSDictionary* data =[dictObject objectForKey:@"data"];
  NSString* type =[dictObject objectForKey:@"type"];
  //for download
  OAMutableURLRequest *URLrequest = [dictObject objectForKey:@"request"];
  
  
  if([type isEqualToString:@"download"])
  {
    self.downloading=YES;
  }
  else {
    self.downloading=NO;
  }
    
  if(URLrequest==nil) {
    NSString* url;
    
    if([[requesturl substringToIndex:1] isEqualToString:@"/"]){ 
	url=[NSString stringWithFormat:@"%@://%@%@",self.scheme,self.host,requesturl];
    }
    else {
	url=[NSString stringWithFormat:@"%@://%@%@",self.scheme,self.host,requesturl];
    }
    
    
    NSString* query=@"";
    
    if(data!=nil) {
      query = [self buildQuery:data];
    }
    
    if(method==GET)
    {
      url = [NSString stringWithFormat:@"%@?%@",url,query];
    }
    OAConsumer *consumer = [[OAConsumer alloc] initWithKey:CONSUMER_KEY
                                                    secret:CONSUMER_SECRET];
    
    OAMutableURLRequest *request =[[OAMutableURLRequest alloc] initWithURL:[NSURL URLWithString:url] consumer:consumer token:nil realm:nil signatureProvider:nil];
    
    [consumer release];
    
    

    
    //start METHOD
    if(method==GET)
    {
      [request setHTTPMethod:@"GET"];
    }
    else if(method==POST || method==PUT)
    {
      NSData* postData=[query dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];
      NSString* postLength=[NSString stringWithFormat:@"%d",[postData length]];
      
      if(method==POST) {
        [request setHTTPMethod:@"POST"];
      }
      else {
        [request setHTTPMethod:@"PUT"];
      }
      [request setValue:@"application/x-www-form-urlencoded" forHTTPHeaderField:@"Content-Type"];
      [request setValue:postLength forHTTPHeaderField:@"Content-Length"];
      [request setHTTPBody:postData];
    }
    else if(method==DELETE)
    {
      //nothing to do
      [request setHTTPMethod:@"DELETE"];
    }
    [request setURL:[NSURL URLWithString:url]];
    
    OADataFetcher *fetcher = [[OADataFetcher alloc] init];
    
    [fetcher fetchDataWithRequest:request delegate:self didFinishSelector:@selector(oAuthDone:WithData:) didFailSelector:@selector(failAuth:WithError:)];
    
        
    [request release];
    
  }
  else {
    
    OADataFetcher *fetcher = [[OADataFetcher alloc] init];
    
    [fetcher fetchDataWithRequest:URLrequest delegate:self didFinishSelector:@selector(oAuthDownloadDone:WithData:) didFailSelector:@selector(failAuth:WithError:)];
   

  }
}

-(void)failAuth:(OAServiceTicket*)service WithError:(NSError*)err {
    NSDictionary* dictObject = [self.queue objectAtIndex:0];
    _httpErrorBlock = [[dictObject objectForKey:@"fail"] copy];
    _httpErrorBlock(err);
}
-(void)oAuthDownloadDone:(OAServiceTicket*)service WithData:(NSMutableData*)data {
  
  NSHTTPURLResponse* httpRespond =(NSHTTPURLResponse*)service.response;
  self.respond.status=httpRespond.statusCode;
  
  self.respond.rawData = data;
  
  NSDictionary* dictObject =[self.queue objectAtIndex:0];
  
  _httpResponseBlock = [[dictObject objectForKey:@"completion"] copy];
  _httpResponseBlock(self.respond);
  
  [self nextConnection];
  
}

-(void)oAuthDone:(OAServiceTicket*)service WithData:(NSMutableData*)data {
  
  NSHTTPURLResponse* httpRespond =(NSHTTPURLResponse*)service.response;
  self.respond.status=httpRespond.statusCode;
  
  self.respond.body = [[[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding] autorelease];
  
  if (self.downloading)
    self.respond.rawData = data;

  NSDictionary* dictObject =[self.queue objectAtIndex:0];

  _httpResponseBlock = [[dictObject objectForKey:@"completion"] copy];
  _httpResponseBlock(self.respond);

  [self nextConnection];

  
}

-(NSString*)buildQuery:(NSDictionary*)data {
  NSString* query=@"";
  for (NSString* key in data) {
    NSString* value;
    if([[data objectForKey:key] isKindOfClass:[NSNumber class]])
    {
      NSNumber* num=[data objectForKey:key];
      value=[num stringValue];
    }
    else {
      value=[data objectForKey:key];
    }
    
    if([query isEqualToString:@""]) {
        query=[NSString stringWithFormat:@"%@=%@",key,value];
    }
    else{
      query=[NSString stringWithFormat:@"%@&%@=%@",query,key,value];
    }
    
    
  }
  return query;
}

-(void)nextConnection {
  [self.queue removeObjectAtIndex:0];
  if([self.queue count] > 0){
    [self startConnection];
  }
  else {
    [UIApplication sharedApplication].networkActivityIndicatorVisible=NO;
  }
}
@end
